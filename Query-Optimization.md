# Оптимізація запитів в MySQL

У цій статті пояснено, як оптимізувати деякі запити MySQL, з навединими прикладами. Оптимізація включає в себе в першу чергу конфігурування, налаштуваня та вимірювання продуктивності. Оптимізація потрібна для того, щоб використовувати ресурси процесора та пам'яті максимально ефективно, покращувати масштабованість бази даних, дозволяючи, їй, також, обробляти більше навантаження з меншими затримками.

Продуктивність бази даних залежить від кількох факторів, на рівні бази даних, її таблиць, запитів, та налаштувань конфігурації. Ці конструкції приводять у рух операції процесора на апаратному рівні, і ви маєте зробити ці операції максимально ефективними. Отже, для того, щоб максимально ефективно використовувати ресурси процесору та часу, потрібно для початку оптимізувати запити. 

## 1. Оптимізація запитів з WHERE

У цьому розділі розглядаються оптимізації, які можна зробити для обробки запитів з WHERE. У прикладах використовуються оператори SELECT, але ті ж самі оптимізації застосовуються у операторах DELETE та UPDATE.

### 1.1 Оптимізація чогось . . .

**Неоптимізований запит**

```SQL
. . .
select * from table0 WHERE a = 1; -- Поганий вид запиту
. . .
```

**результат запиту**

**вивід EXPLAIN**

| id | select_type | table | partitions | type | possible_keys | key | key_len | ref  | rows | filtered | Extra |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | 
| 1 | SIMPLE | _countries | NULL | ALL | NULL | NULL | NULL | NULL |  234 | 11.11 | Using where |

**висновок**

**Оптимізований запит**

```SQL
. . .
select * from table0 WHERE b = 1; -- Оптимальний вид запиту
. . .
```

**результат запиту**

**вивід EXPLAIN**

| id | select_type | table | partitions | type | possible_keys | key | key_len | ref  | rows | filtered | Extra |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | 
| 1 | SIMPLE | _countries | NULL | ALL | NULL | NULL | NULL | NULL |  234 | 11.11 | Using where |

**висновок**

### 1.2 Оптимізація чогось . . .

**Неоптимізований запит**

```SQL
. . .
select * from table0 WHERE a = 1; -- Поганий вид запиту
. . .
```

**результат запиту**

**вивід EXPLAIN**

| id | select_type | table | partitions | type | possible_keys | key | key_len | ref  | rows | filtered | Extra |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | 
| 1 | SIMPLE | _countries | NULL | ALL | NULL | NULL | NULL | NULL |  234 | 11.11 | Using where |

**висновок**

**Оптимізований запит**

```SQL
. . .
select * from table0 WHERE b = 1; -- Оптимальний вид запиту
. . .
```

**результат запиту**

**вивід EXPLAIN**

| id | select_type | table | partitions | type | possible_keys | key | key_len | ref  | rows | filtered | Extra |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | 
| 1 | SIMPLE | _countries | NULL | ALL | NULL | NULL | NULL | NULL |  234 | 11.11 | Using where |

**висновок**

## 2. Оптимізація запитів з діапазоном

## 3. Оптимізація запитів з GROUP BY

## 4. Індекси в MySQL

### 4.1 Класифікація Індексів

Індекси бувають **кластерні** та **некластерні**.

У чому різниця? 

Некластерний індекс зберігає тільки посилання на записи таблиці. Коли відбувається робота з індексом, визначається тільки список записів (точніше список їх первинних ключів), що підходять під запит. Після цього відбувається ще один запит - для отримання даних кожного запису з цього списку.

Кластерні індекси зберігають дані записів цілком, а не посилання на них. При роботі з таким індексом не потрібно додаткової операції читання даних.

Некластерні в свою чергу поділяються на декілька видів.

**Найпростіший** з них, приклад якого ми вже бачили в попередніх слайдах, створюється для тих колонок, які присутні в умові WHERE та в умові яких є ORDER BY.

Також існують **унікальні індекси** для колонок, значення в яких повинні бути унікальними по всій таблиці. Такі індекси покращують ефективність вибірки для унікальних значень.

Ще є **складені індекси**, для запитів, в яких використовується кілька колонок, бо MySQL може використовувати тільки один індекс для запиту (крім випадків, коли MySQL здатний об'єднати результати вибірок за кількома індексами). Вони використовуються для пошуку по діапазону та сортування.

## 4.1 Найпростіші Індекси

### Без Індексу

**Запит без індексу**

```SQL
. . .
select * from table0 WHERE a = 1; -- запит без індексу
. . .
```

**результат запиту**

**вивід EXPLAIN**

| id | select_type | table | partitions | type | possible_keys | key | key_len | ref  | rows | filtered | Extra |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | 
| 1 | SIMPLE | _countries | NULL | ALL | NULL | NULL | NULL | NULL |  234 | 11.11 | Using where |


### Створення Індексу

```SQL
. . .
CREATE INDEX country_id ON _cities(country_id); -- створення індексу
. . .
```

### Використання Індексу

**результат запиту**

**вивід EXPLAIN**

| id | select_type | table | partitions | type | possible_keys | key | key_len | ref  | rows | filtered | Extra |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | 
| 1 | SIMPLE | _countries | NULL | ALL | NULL | NULL | NULL | NULL |  234 | 11.11 | Using where |

### Висновок

З найпростішими індексами можна прискорити роботу . . .

## . . . Індекс

. . .

## 5. Висновок

. . . Більше про оптимізацію ви зможете дізнатися в [офіційній документації MySQL](https://dev.mysql.com/doc/refman/8.0/en/optimization.html "MySQL Optimization Documentaion").

## 6. Автори

*  [Василиненко Даніїл](http://example.com/link "github")

*  [Головко Андрій](http://example.com/link "github")

## 7. Посилання

*  [Документація про оптимізацію в MySQL](https://dev.mysql.com/doc/refman/8.0/en/optimization.html "MySQL Optimization Documentaion")